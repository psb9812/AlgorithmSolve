/*
백준 2193번
	이친수

풀이:
	일단 문제만 보고 뭐로 풀어야 하지 감이 잘 오지 않았다.
	그럴 때는 끄적이면서 문제의 경우들을 시각적으로 보는 행위가 도움이 되는 것 같다.
	그러다보니 피보나치 수열처럼 개수가 증가하는 것 같았는데 왜 그런지는 모르겠다.

	규칙을 분석해보니
	n번째 자리수의 이친수를 구하려면 n-1번 자리수의 [0으로 끝나는 수의 개수]와 [1로 끝나는 수의 개수]가 필요했다.
	근데 그 각각의 개수들도 이전항의 연관성있는 규칙이 있었다.

	그래서 점화식을 찾아서 DP로 문제를 풀었다.

	그런데 틀렸다고 나왔다...
	논리는 맞는 것 같은데 틀렸다면 데이터 타입을 검토해볼만 했다.
	90자리수의 이친수의 개수는 피보나치 수열의 90번째 수이므로 수가 굉장히 커짐을 알아챘다.
	바로 long long으로 바꿔서 제출했더니 맞았다.
*/

#include <iostream>
using namespace std;

long long Z[91];		//Z[k] : K자리수의 이친수 중 마지막이 0인 수의 개수
long long O[91];		//O[k] : K자리수의 이친수 중 마지막이 1인 수의 개수
long long D[91];		//D[k] : K자리수의 이친수의 개수
int n;

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	cin >> n;

	Z[1] = 0;
	O[1] = 1;
	D[1] = 1;

	for (int k = 2; k <= n; k++)
	{
		Z[k] = D[k - 1];
		O[k] = Z[k - 1];
		D[k] = 2 * Z[k - 1] + O[k - 1];
	}
	cout << D[n];
}